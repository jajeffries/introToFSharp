\documentclass[landscape]{slides}

\usepackage[landscape]{geometry}
\usepackage{verbatim}

\author{James Jeffries}
\title{A Brief Overview of F\#}
\date{7th June 2012}

\begin{document}

\begin{slide}
\maketitle
@jjeffries1
github.com/jajeffries/introToFSharp
\end{slide}

\begin{slide}{Overview}
\begin{itemize}
\item Functional programming 
\item Features of F\#
\item Interoperating with .NET
\end{itemize}
\end{slide}

\begin{slide}{What is F\#?}
\begin{itemize}
\item A functional language base that runs on the .NET framework
\begin{itemize}
\item can call existing .NET libraries
\item can make libraries to be called by other .NET code
\end{itemize}
\item Shares the core of the language with OCaml
\end{itemize}
\end{slide}

\begin{slide}{What is functional programming and why use it?}
\begin{itemize}
\item Treats computation as the evaluation of functions and avoids state and mutable data
\item Avoiding state makes it easier to test and reason about code
\item If there are no dependencies between functions they can be performed in parallel
\item It's generally more conicse - writing less code makes it harder to write in bugs
\end{itemize}
\end{slide}

\begin{slide}{Hello World Explained}
\begin{verbatim}
let _ = println "Hello World"
\end{verbatim}
\begin{itemize}
\item let - binds an expression to a name
\item \_ - is the main or entry point
\item println - is the print function
\end{itemize}
\end{slide}

\begin{slide}{Functions}
\begin{verbatim}
let add a b = a + b
\end{verbatim}
\begin{itemize}
\item Type of this function is
\begin{verbatim}
val add : int -> int -> int
\end{verbatim}
\item Takes 2 ints and returns an int
\end{itemize}
\end{slide}

\begin{slide}{A More Detailed Example}
\begin{verbatim}
#light

let sqr x = x * x

let sumOfSquares nums =
    let mutable acc = 0
    for x in nums do
        acc <- acc + sqr x
    acc

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Taking a more functional approach}
\begin{verbatim}
#light

let sqr x = x * x

let rec sumOfSquares nums =
    match nums with
    | []   -> 0.0
    | h::t -> sqr h + sumOfSquares t

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Using Pipelines}
\begin{verbatim}
#light

let sqr x = x * x

let sumOfSquares nums =
    nums 
    |> Seq.map sqr
    |> Seq.sum

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Using Lambdas}
\begin{verbatim}
#light

let sumOfSquares nums =
    nums 
    |> Seq.map (fun x -> x * x) 
    |> Seq.sum

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\end{document}

\documentclass[landscape]{slides}

\usepackage[landscape]{geometry}
\usepackage{verbatim}
\usepackage{hyperref}

\author{James Jeffries}
\author{\parbox{.5\textwidth}{\centering
  James Jeffries \\
  \small Twitter: \href{http://www.twitter.com/jjeffries1}{@jjeffries1} \\[3pt]
  Github: \href{https://github.com/jajeffries/introToFSharp}{github.com/jajeffries/introToFSharp}}}

\title{An Introduction to F\#}

\begin{document}

\begin{slide}
\maketitle
\end{slide}

\begin{slide}{Overview}
\begin{itemize}
\item An overview of some of the basic syntax
\item Examples of some of the cooler parts of F\#
\end{itemize}
\end{slide}

\begin{slide}{Trying examples}
\begin{itemize}
\item You should be able to try out any of the examples using
\begin{itemize}
\item Visual Studio 2010 or above with the F\# interactive console
\item F\# on mono - this is a bit tricky to set up though
\item LINQPad
\item www.tryfsharp.org
\item www.tryfs.net
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{What is F\#?}
\begin{itemize}
\item A functional language base that runs on the .NET framework
\begin{itemize}
\item can call existing .NET libraries
\item can make libraries to be called by other .NET code
\end{itemize}
\item Shares the core of the language with OCaml
\end{itemize}
\end{slide}

\begin{slide}{Let bindings}
\begin{itemize}
\item Binds an expression to a name
\item Immutable by default
\item Type is inferred
\end{itemize}
\begin{verbatim}
let x = "Hello"
\end{verbatim}
\end{slide}

\begin{slide}{Mutable let bindings}
\begin{itemize}
\item Can make a let binding mutable using the mutable keyword 
\item Can't change the type when changing the value of a mutable variable
\end{itemize}
\begin{verbatim}
let mutable var = 5 

var <- 7 // correct
var <- 9 // correct
var <- "Hello" //incorrect
\end{verbatim}
\end{slide}

\begin{slide}{Function Bindings}
\begin{verbatim}
let add a b = a + b
\end{verbatim}
\begin{itemize}
\item Type of this function is
\begin{verbatim}
val add : int -> int -> int
\end{verbatim}
\item Takes 2 ints and returns an int
\end{itemize}
\end{slide}

\begin{slide}{Currying}
\begin{verbatim}
let add a b = a + b
let addOne = add 1

let _ =
    printfn "%d" (addOne 3)
\end{verbatim}
\begin{itemize}
\item Currying allows us to effectively create a function with arguments already specified
\item addOne has the following type. It returns a function that takes an int and returns an int
\end{itemize}
\begin{verbatim}
val addOne : (int -> int)
\end{verbatim}
\end{slide}

\begin{slide}{Type annotations}
\begin{itemize}
\item Can specify types instead of relying on type inference
\end{itemize}
\begin{verbatim}
let intIncrement (x:int) = x + 1

let floatIncrement (x:float) = x + 1.0
\end{verbatim}
\end{slide}

\begin{slide}{Automatic generalisation}
\begin{itemize}
\item When the compiler does type inference it tries to determine which parameters can be generic and which need constraints.
\begin{verbatim}
> let max a b = if a > b then a else b ;;
val max : 'a -> 'a -> 'a when 'a : comparison
\end{verbatim}
\item Here the compiler has determined that the parameters can be generic, but must be able to be compared
\end{itemize}
\end{slide}

\begin{slide}{A More Detailed Let Example}
\begin{verbatim}
#light

let sqr x = x * x

let sumOfSquares nums =
    let mutable acc = 0
    for x in nums do
        acc <- acc + sqr x
    acc

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{A More Detailed Example Explained}
\begin{description}
\item[\#light] use lightweight syntax
\item[mutable] declares a mutable variable. By default let binds an immutable value to a name.
\item[\textless-] puts the value of the expression on the right into the variable on the left
\item[acc] the last expression is the return a value
\end{description}
\end{slide}

\begin{slide}{A More Detailed Example Explained (continued...)}
\begin{itemize}
\item This is not good style as it is more imperative
\item Can be useful when first starting to write like this to get an understanding of the language
\item Also useful when using existing .NET libraries that aren't written in a functional style
\end{itemize}
\end{slide}

\begin{slide}{Taking a more functional approach}
\begin{verbatim}
#light

let sqr x = x * x

let rec sumOfSquares nums =
    match nums with
    | []   -> 0.0
    | h::t -> sqr h + sumOfSquares t

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Taking a more functional approach explained}
\begin{description}
\item[rec] declares a recursive function. Functions aren't recursive by default.
\item[match] matches a pattern. Sort of like a switch statement. match returns a value so we don't need to specify what to return seperately
\item[h::t] splits a list into it's head and tail. Binds the head to h and tail to t
\end{description}
\end{slide}

\begin{slide}{Options}
\begin{description} 
\item like haskell's maybe (I think)
\begin{verbatim}
type Option<'a> =
    | Some of 'a
    | None

let mySomeOption = Some("A Value")
let myNoneOption = None

let processOption opt =
  match opt with
  | Some(opt) -> printfn "%s" opt
  | None -> printfn "%s" "No Value"
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{Using match and options}
\begin{itemize}
\item An option type can hold two possible values: Some(x) or None.
\item Often used to indicate success or failure of a computation
\end{itemize}
\begin{verbatim}
let safediv x y = 
  match y with
  | 0 -> None
  | _ -> Some(x/y)
 
// val safediv : int -> int -> int option
\end{verbatim}
\end{slide}

\begin{slide}{Using Pipelines}
\begin{verbatim}
#light

let sqr x = x * x

let sumOfSquares nums =
    nums 
    |> Seq.map sqr
    |> Seq.sum

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Using Pipelines Explained}
\begin{itemize}
\item pipelines are similar to pipes in unix
\item they allow you to pipe the result of the previous expression into the last argument of the next expression
\end{itemize}
\end{slide}

\begin{slide}{Using Lambdas}
\begin{verbatim}
#light

let sumOfSquares nums =
    nums 
    |> Seq.map (fun x -> x * x) 
    |> Seq.sum

let _ = sumOfSquares [1;2;3;4]
\end{verbatim}
\end{slide}

\begin{slide}{Using Lambdas Explained}
\begin{itemize}
\item lambdas are anonymous functions
\item declared using the fun keyword
\end{itemize}
\end{slide}

\begin{slide}{The type keyword}
\begin{description}
\item[Type abbreviations] similar to C++'s typedef. For example:
\begin{verbatim}
type SizeType = uint32
\end{verbatim}
Also works with generics
\begin{verbatim}
type Reducer<'a, 'b> = 'a -> 'b -> 'a
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\item[Classes] Compile down to the same IL (bytecode) as other .NET classes
\begin{verbatim}
type MyClass(x: string) =        
  let private_value = x
  do
    printfn "%s" private_value
  member this.PublicProperty = 
    "Public: " + private_value
  member this.PrintPublicProperty() =
    printfn "%s" this.PublicProperty
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\item[Inheritance] sorry if this examples a bit compact 
\begin{verbatim}
type Point(x: int, y: int) as this =
  do
    this.PrintPoint()
  member this.X = x
  member this.Y = y
  new() = Point(0, 0)
  member this.PrintX() = printfn "%d" this.X
  member this.PrintY() = printfn "%d" this.Y
  abstract PrintPoint : unit -> unit
  default this.PrintPoint() = 
    printfn "Point(%d, %d)" this.X this.Y
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\begin{verbatim}
type NamedPoint(name: string, x: int, y: int) =
  inherit Point(x, y)
  member this.Name = name

  override this.PrintPoint() =
    printfn "Name: %s Point(%d, %d)" this.Name this.X this.Y
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\item[Structures] Value types that are allocated on the stack 
\begin{verbatim}
type Point1D =
  struct 
    // val declares an unitialised field 
    val x: float
  end

[<Struct>]
type AlternatePoint1D = 
  val x: float
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\item[Records] aggregates of named values
\begin{verbatim}
type MyRecord = { X: int; Y: int; Z: int }

let myRecord1 = { X = 1; Y = 2; Z = 3; }

let myRecord2 = {
    MyRecord.X = 1; 
    MyRecord.Y = 2; 
    MyRecord.Z = 3 
  }
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{The type keyword (continued...)}
\begin{description}
\item[Unions] can be one of several named cases 
\begin{verbatim}
type BinaryTree =
  | Leaf of int
  | Node of int * BinaryTree * BinaryTree

let myTree = Node(1, 
                 Node(3, Leaf(2), Leaf(4)), 
                 Node(6, Leaf(5), Leaf(7)))
\end{verbatim}
\end{description}
\end{slide}

\begin{slide}{Interesting features of F\#}
\begin{itemize}
\item The next part of the talk shows off some of the more interesting parts of F\#
\begin{itemize}
\item Active Patterns
\item Asynchronous Workflows
\item Units of Measure
\end{itemize}
\end{itemize}
\end{slide}

\begin{slide}{Active Patterns}
\begin{itemize}
\item allows you to write custom patterns to use in match expressions
\end{itemize}
\begin{verbatim}
let (|Odd|Even|) x = if x % 2 = 0 then Even else Odd
let isDivisibleByTwo x = 
  match x with 
  | Even -> true 
  | Odd -> false
\end{verbatim}
\end{slide}

\begin{slide}{Asynchronous Workflows}
\begin{itemize}
\item allow you to define units of work that can be executed asynchronously
\item a type of computation expression
\end{itemize}
\end{slide}

\begin{slide}{Units of Measure}
\begin{itemize}
\item integral and floating point values can be assigned a unit of measure
\item helps to avoid errors when working with values of different types of measurement
\item see example code for further details
\end{itemize}
\end{slide}

\begin{slide}{What haven't we covered}
\begin{itemize}
\item Collections
\item New things from F\# 3.0
\begin{itemize}
\item better LINQ support
\item type providers
\item auto properties
\end{itemize}
\item Laziness
\item Message passing
\end{itemize}
\end{slide}

\begin{slide}{Where can I learn more?}
\begin{itemize}
\item Expert F\# by Don Syme, Adam Granicz and Antonio Cisternino - very detailed and lots of good explanations
\item \href{http://channel9.msdn.com/blogs/pdc2008/tl11}{http://channel9.msdn.com/blogs/pdc2008/tl11} by Luca Bolognese - good overview to get you started with lots of useful tips
\item \href{http://msdn.microsoft.com/en-us/vstudio/hh386303}{http://msdn.microsoft.com/en-us/vstudio/hh386303} - lots of good videos and tutorials
\end{itemize}
\end{slide}

\end{document}
